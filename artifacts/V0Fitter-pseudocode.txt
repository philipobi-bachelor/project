fitAndStore(
    const *track+/-, 
    &v0Hypothesis, 
    &isForceStored, 
    &isHitRemoved
    ){
    
    isForceStored = false
    isHitRemoved = false
    
    recoTrack+/- = track+/-.getRelated<RecoTrack>(reco track store array name)
    
    vertexPos = (0,0,0)

    hasInnerHitStatus = 0

    return false if not vertexFitWithRecoTracks(
        const *track+/-,
        *recoTrack+/-
        &v0Hypothesis,
        &hasInnerHitStatus,
        &vertexPos,
        const m_forcestore    
    )

    if ( no inner hits or force store ) return true

    failflag = false
    
    const trackHypotheses = (particleHypTrack1, particleHypTrack2) = getTrackHypotheses(v0Hypothesis)

    const pdg+/- = track+/-.getTrackFitResultWithClosestMass(particleHypTrack1/2).particleType.pdgCode

    recoTrack+/-_forRefit = null
    cache_recoTrack+/- = null

    count_removeInnerHits = 0
    
    while ( hasInnerHitStatus != 0 ) {
        ++count_removeInnerHits
        if ( hasInnerHitStatus & flag+/- ) {

            recoTrack+/-_forRefit = copyRecoTrack(recoTrack+/-)
            if ( copy failed ) return false
            break if not removeInnerHits(
                *prevRecoTrack: cache_recoTrack+/- if not null else recoTrack+/-,
                *recoTrack: recoTrack+/-_forRefit,
                const pdg+/-,
                const &vertexPosition
                ) {
                if ( prevRecoTrack or recoTrack is null ) return false
                
                particleUsedForFitting = ChargedStable(pdg)
                prevTrackRep = prevRecoTrack.getTrackRepForPDG(pdg)
                hitInfo = recoTrack.getRecoHitInfo(sorted: true)
                prev_hitInfo = prevTrack.getRecoHitInfo(sorted: true)

                nRemoved = 0
                
                if ( hitInfo.size != prev_hitInfo.size )
                    return false

                for i < hitInfo.size {
                    if ( 
                        not prev_hitInfo[i].useInFit or
                        no fit info for hit
                         ) {
                        hitInfo[i].useInFit = false
                        nRemoved++
                        continue
                    }

                    statePrev = copy(prevRecoTrack.getMSOPfromHit(prev_hitInfo[i]))

                    len = statePrev.extrapolateToPoint(vertexPos)
                    if ( extrapolation fails ) return false

                    if ( len > 0 ) // hit before vertex
                        hitInfo[i].useInFit = false
                        nRemoved++
                    else break
                }

                if ( nRemoved == 0 ) return false
                if ( hitInfo.size <= nRemoved ) return false //removed all hits

                // also remove V hit if previous hit was U hit
                if (
                    last removed hit is svd hit and
                    first kept hit is svd hit
                    ) {
                    clusterLast = hitInfo[nRemoved - 1].getRelated(SVDCluster)
                    cluster = hitInfo[nRemoved].getRelated(SVDCluster)
                    if (!clusterLast or !cluster) log error
                    else {
                        if ( 
                            clusterLast.sensor == cluster.sensor and
                            clusterLast.UCluster and 
                            not cluster.UCluster
                            ) {
                                hitInfo[nRemoved].useInFit = false
                                nRemoved++
                            }
                    }
                }

                // if option (use only one svd hit pair) not used
                // remove remaining svd hit pair if exists
                if (
                    not m_useOnlyOneSVDHitPair and
                    hitInfo.size > nRemoved + 2 and
                    hitInfo[nRemoved + -1..1].detector == SVD and
                    hitInfo[nRemoved + 2].detector != SVD
                    ) {
                    hitInfo[nRemoved + 0..1].useInFit = false
                    nRemoved += 2
                }

                TrackFitter fitter
                fitter.fit(recoTrack, particleUsedForFitting)
                if ( fit failed ) return false
                return true
            }     
            
            cache_recoTrack+/- = recoTrack+/-_forRefit
        
        } elif ( recoTrack+/-_forRefit == null ) { 
            // first iteration and no inner hit on this track
            recoTrack+/-forRefit = copyRecoTrackAndFit(
                recoTrack+/-,
                pdg+/-
                ) {
                particleUsedForFitting = ChargedStable(pdg)
                origTrackRep = recoTrack.getRepForPDG(pdg)
                newRecoTrack = copyRecoTrack(recoTrack)

                TrackFitter fitter
                fitter.fit(
                    newRecoTrack,
                    particleUsedForFitting
                )
                if ( failed ) return null
                return newRecoTrack
            }
            if ( recoTrack+/-_forRefit == null ) return false
        }
        
        hasInnerHitStatus = 0;
        vertexFitWithRecoTracks(
            const *track+/-,
            *recoTrack+/-_forRefit,
            const &v0Hypothesis,
            &hasInnerHitStatus,
            &vertexPos,
            const forceStore: false
        )
        if ( failed ) failflag = true, break
        elif ( hasInnerHitStatus == 0 ) isHitRemoved = true 
        // couldnt remove inner hits after multiple iterations
        if ( count_removeInnerHits >= 5 ) failflag = true, break
    }

    if ( not failflag ) return true

    // revert to original vertex
    return false if not vertexFitWithRecoTracks(
        const *track+/-,
        *recoTrack+/-,
        const &v0Hypothesis,
        &hasInnerHitStatus,
        &vertexPos,
        const forcestore = true
    )

    isForceStored = true
    return true
}

vertexFitWithRecoTracks(
    const *track+/-,
    *recoTrack+/-
    &v0Hypothesis,
    &hasInnerHitStatus,
    &vertexPos,
    const forceStore
    ) {
    const trackHypotheses = (particleHypTrack1, particleHypTrack2) = getTrackHypotheses(v0Hypothesis)

    const pdg+/- = track+/-.getTrackFitResultWithClosestMass(particleHypTrack1/2).particleType.pdgCode
    
    trackRep+/- = recoTrack+/-.getTrackRepForPdg(pdg+/-)
    
    if (
        not trackRep+/- or
        not recoTrack+/-.fitSuccessful(trackRep+/-)
    ) return false

    gfTrack+/- = copy(get_genfit(recoTrack+/-))

    gfTrackReps+/- = gfTrack+/-.getTrackReps

    for rep+/- in trackReps+/- {
        if ( rep+/-.pdg == pdg+/- )
            gfTrack+/-.setCardinalRep(rep+/-)
    }

    state+/- = copy(recoTrack+/-.MSOPfromFirstHit(trackRep+/-))

    GFRaveVertex vertex;

    return false if not 
    fitGFRaveVertex(
        &gfTrack+/-,
        &vertex
        ) {
        vertexVector;
        trackPair = {&gfTrack+, &gfTrack-}
        vertexFactory.findVertices(&vertexVector.v, trackPair)

        if ( error or not fit successful ) return false
        else {
            vertex = *vertexVector[0]
            return true
        }
    }
    
    vertexPos = RootVector(vertex.getPos())

    if ( vertex doesnt pass cuts )
        return false

    return false if not
    extrapolateToVertex(
        &state+/-,
        const &vertexPos,
        &hasInnerHitStatus
        ) {
            hasInnerHitStatus = 0
            len+/- = state+/-.extrapolateToPoint(vertexPos)
            if ( len+/- > 0 ) set hasInnerHitStatus bits
            if ( error ) return false
            return true
    }

    if (
        forceStore or
        hasInnerHitStatus == 0
    ) {
        trackParams0/1 = vertex.getParameters(0/1)
        lorentzVector0/1 = rootPxPyPzMVector(
            trackParams0/1.getMom().Px(), .Py(), .Pz(),
            particleTrackHyp0/1.getMass() 
        )

        v0InvMass = (lorentzVector0 + lorentzVector1).M()

        if ( v0InvMass and v0Hypothesis.invMassRange not overlap ) 
            return false

        Bz = BFieldManager.getFieldInTesla({0,0,0}).Z()

        sharedInnermostCluster = checkSharedInnermostCluster(
            const *recoTrack+/-
            ) {
            flag = 0
            const &hitInfo+/- = recoTrack+/-.getRecoHitInformation(sorted=true)

            iFirstHit+/- = 0
            // get first hit index of reco tracks used in fit
            for hit in hitInfo+/- {
                if ( hit.useInFit() ) break
                ++iFirstHit+/- 
            }

            if ( iFirstHit+/- == hitInfo+/-.size() ) // no hit used in fit
                return -1

            const &firstHitInfo+/- = hitInfo+/-[iFirstHit+/-]

            if not ( firstHitInfo+.detector == firstHitInfo-.detector ) return 0

            if ( firstHitInfo.detector == PXD ) {
                const *cluster+/- = firstHitInfo+/-.getRelated(PXDCluster)
                if ( cluster+ == cluster- ) flag = 3
            }
            else if ( firstHitInfo.detector == SVD ) {
                const *cluster+/- = firstHitInfo+/-.getRelated(SVDCluster)
                if ( 
                    not cluster+/-.isUCluster() or
                    not iFirstHit+/- + 1 < hitInfo+/-.size
                ) return -1
                
                const &nextHitInfo+/- = hitInfo+/-[iFirstHit+/- + 1]

                if not (
                    nextHitInfo+/-.useInFit() and 
                    nextHitInfo+/-.detector == SVD
                ) return -1

                const *clusterNext+/- = nextHitInfo+/-.getRelated(SVDCluster)

                if ( // next clusters are V clusters from same sensor
                    not clusterNext+/-.isUCluster and 
                    cluster+/-.sensorID() == clusterNext+/-.sensorID() 
                ) { // U and V clusters are shared
                    if ( cluster+ == cluster- ) flag += 2
                    if ( clusterNext+ == clusterNext- ) flag += 1
                } else return -1
            }

            return flag
        }

        fitResVertex+/- = buildTrackFitResult(
            const &gfTrack+/-,
            const *recoTrack+/-,
            const &state+/-,
            const Bz,
            const &particleHypTrack1/2,
            const sharedInnermostCluster
            ) {
            hitCDCInit = TrackBuilder.getHitPatternCDCInitializer(recoTrack)
            hitVXDInit = TrackBuilder.getHitPatternVXDInitializer(recoTrack)

            // innermost hit shared among V0 daughters
            if ( 0 < sharedInnermostCluster < 4) {
                hitVXDflag = HitPatternVXD(hitVXDInit)
                hitVXDflag.setInnermostHitShareStatus(sharedInnermostCluster)
                hitVXDInit = hitVXDflag.getInteger()
            }

            v0TrackFitResult = m_trackFitResults.appendNew(
                state.getPos(), // pos near perigee
                state.getMom(), // mom near perigee
                state.get6DCov(), // cov matrix for pos, mom
                state.getCharge(), // particle charge
                particleHypTrack, // particle type used for track fit mass hyp
                gfTrack.fitStatus.PVal, // track fit p value
                Bz, // magnetic field for curvature
                hitCDCInit, // bits for init of CDC hit pattern
                hitVXDInit, // bits for init of VXD hit pattern
                gfTrack.fitStatus.Ndf // ndf of fit
            )
            
            return V0TrackFitResult
        }

        v0 = m_v0s.appendNew(
            (track+/-, fitRes+/-),
            vertexPos.X, .Y, .Z
        )

        if ( m_validation ) {
            validationV0 = m_validationV0s.appendNew(
                (track+/-, fitRes+/-),
                RootVector(vertex.getPos()), // fitted vertex position
                vertex.getCov(), // covariance of vertex position
                // reconstructed momentum and inv. mass
                (lorentzVector0 + lorentVector1).P(),
                .M(),
                vertex.getChi2() // chi2 of vertex fit
            )
            v0.addRelationTo(validationV0)
        }

        return true
    }

}